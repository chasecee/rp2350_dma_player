#!/usr/bin/env python3
"""
Raw SD Card Frame Writer

This script writes frames.bin directly to raw SD card sectors,
completely bypassing the file system for maximum performance.

DANGER: This writes directly to the SD card device. Make sure you
have the correct device path or you'll nuke something important!

Usage:
    sudo python3 write_raw_frames.py /dev/disk6 frames.bin

Requirements:
    - Root access (sudo)
    - frames.bin file generated by convert.py
    - Correct SD card device path
"""

import os
import sys
import stat
import struct
import argparse
import subprocess
import re

# SD card parameters
RAW_START_SECTOR = 2048    # Start after partition table/boot sectors
BYTES_PER_SECTOR = 512     # Standard SD sector size
FRAME_SIZE_BYTES = 233 * 233 * 2  # 233x233 RGB565 (raw frame size)
# Use sector-aligned frame size for optimal performance (must match convert.py and raw_sd_loader.c)
PADDED_FRAME_SIZE_BYTES = ((FRAME_SIZE_BYTES + BYTES_PER_SECTOR - 1) // BYTES_PER_SECTOR) * BYTES_PER_SECTOR

def get_device_info_macos(device_path):
    """Get device size using macOS diskutil command"""
    try:
        # Extract disk identifier (e.g., "disk6" from "/dev/disk6" or "/dev/rdisk6")
        disk_match = re.search(r'r?disk(\d+)', device_path)
        if not disk_match:
            raise ValueError(f"Cannot extract disk identifier from {device_path}")
        
        disk_id = f"disk{disk_match.group(1)}"
        
        # Use diskutil to get disk info
        result = subprocess.run(['diskutil', 'info', disk_id], 
                              capture_output=True, text=True)
        if result.returncode != 0:
            raise ValueError(f"diskutil failed: {result.stderr}")
        
        # Parse the output to find disk size
        for line in result.stdout.split('\n'):
            if 'Disk Size:' in line:
                # Extract size in bytes (format: "Disk Size: 31.9 GB (31914983424 Bytes) (exactly 62333952 512-Byte-Units)")
                bytes_match = re.search(r'\((\d+) Bytes\)', line)
                if bytes_match:
                    return int(bytes_match.group(1))
        
        raise ValueError("Could not find disk size in diskutil output")
        
    except subprocess.CalledProcessError as e:
        raise ValueError(f"diskutil command failed: {e}")
    except Exception as e:
        raise ValueError(f"Error getting device size: {e}")

def get_device_info(device_path):
    """Get device size and verify it's a block device"""
    if not os.path.exists(device_path):
        raise FileNotFoundError(f"Device {device_path} does not exist")
    
    # Check if it's a block device (works on macOS)
    try:
        file_stat = os.stat(device_path)
        if not stat.S_ISBLK(file_stat.st_mode):
            # On macOS, disk devices might show up as character devices
            if not stat.S_ISCHR(file_stat.st_mode):
                raise ValueError(f"{device_path} is not a block or character device")
    except OSError as e:
        raise ValueError(f"Cannot stat {device_path}: {e}")
    
    # Get device size - use macOS-specific method
    if sys.platform == 'darwin':  # macOS
        return get_device_info_macos(device_path)
    else:
        # For other platforms, try the standard method
        try:
            with open(device_path, 'rb') as f:
                f.seek(0, 2)  # Seek to end
                device_size = f.tell()
        except OSError as e:
            raise ValueError(f"Cannot determine size of {device_path}: {e}")
        
        return device_size

def verify_frames_file(frames_path):
    """Verify the frames.bin file exists and get frame count"""
    if not os.path.exists(frames_path):
        raise FileNotFoundError(f"Frames file {frames_path} does not exist")
    
    file_size = os.path.getsize(frames_path)
    if file_size % PADDED_FRAME_SIZE_BYTES != 0:
        print(f"WARNING: File size {file_size} is not evenly divisible by padded frame size {PADDED_FRAME_SIZE_BYTES}")
        print(f"Raw frame size: {FRAME_SIZE_BYTES}, Padded: {PADDED_FRAME_SIZE_BYTES}, Padding: {PADDED_FRAME_SIZE_BYTES - FRAME_SIZE_BYTES} bytes")
    
    num_frames = file_size // PADDED_FRAME_SIZE_BYTES
    print(f"Found {num_frames} frames in {frames_path} ({file_size} bytes)")
    print(f"Frame size: {FRAME_SIZE_BYTES} bytes raw, {PADDED_FRAME_SIZE_BYTES} bytes padded")
    return num_frames, file_size

def write_raw_frames(device_path, frames_path, dry_run=False):
    """Write frames.bin directly to raw SD card sectors"""
    
    # Verify inputs
    device_size = get_device_info(device_path)
    num_frames, frames_size = verify_frames_file(frames_path)
    
    # Calculate space requirements
    start_byte_offset = RAW_START_SECTOR * BYTES_PER_SECTOR
    total_bytes_needed = frames_size
    end_byte_offset = start_byte_offset + total_bytes_needed
    
    print(f"Device: {device_path} ({device_size:,} bytes)")
    print(f"Start offset: sector {RAW_START_SECTOR} = {start_byte_offset:,} bytes")
    print(f"Frames data: {total_bytes_needed:,} bytes")
    print(f"End offset: {end_byte_offset:,} bytes")
    
    if end_byte_offset > device_size:
        raise ValueError(f"Not enough space on device! Need {end_byte_offset:,} bytes, device has {device_size:,}")
    
    if dry_run:
        print("DRY RUN: Would write frames starting at sector", RAW_START_SECTOR)
        return
    
    # Confirm destructive operation
    print(f"\nWARNING: This will overwrite data on {device_path} starting at sector {RAW_START_SECTOR}!")
    response = input("Type 'YES' to continue: ")
    if response != "YES":
        print("Aborted.")
        return
    
    # Write frames data
    print(f"Writing {num_frames} frames to {device_path}...")
    
    try:
        with open(device_path, 'r+b') as device_file:
            with open(frames_path, 'rb') as frames_file:
                # Seek to start position
                device_file.seek(start_byte_offset)
                
                # Copy in chunks for progress tracking
                chunk_size = 1024 * 1024  # 1MB chunks
                bytes_written = 0
                
                while True:
                    chunk = frames_file.read(chunk_size)
                    if not chunk:
                        break
                    
                    device_file.write(chunk)
                    bytes_written += len(chunk)
                    
                    progress = (bytes_written / frames_size) * 100
                    print(f"Progress: {progress:.1f}% ({bytes_written:,}/{frames_size:,} bytes)", end='\r')
                
                # Ensure data is flushed to device
                device_file.flush()
                os.fsync(device_file.fileno())
                
        print(f"\nSuccessfully wrote {bytes_written:,} bytes ({num_frames} frames)")
        print(f"Frames start at sector {RAW_START_SECTOR} on {device_path}")
        
        # Write a metadata file for reference
        metadata_path = frames_path + ".raw_info"
        with open(metadata_path, 'w') as f:
            f.write(f"device={device_path}\n")
            f.write(f"start_sector={RAW_START_SECTOR}\n")
            f.write(f"num_frames={num_frames}\n")
            f.write(f"frame_size_bytes={FRAME_SIZE_BYTES}\n")
            f.write(f"padded_frame_size_bytes={PADDED_FRAME_SIZE_BYTES}\n")
            f.write(f"padding_per_frame={PADDED_FRAME_SIZE_BYTES - FRAME_SIZE_BYTES}\n")
            f.write(f"total_bytes={frames_size}\n")
        print(f"Metadata written to {metadata_path}")
        
    except PermissionError:
        print("ERROR: Permission denied. Make sure to run with sudo.")
    except Exception as e:
        print(f"ERROR: {e}")

def main():
    parser = argparse.ArgumentParser(description="Write frames.bin directly to raw SD card sectors")
    parser.add_argument("device", help="SD card device path (e.g., /dev/disk6)")
    parser.add_argument("frames_file", help="frames.bin file to write")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be done without actually writing")
    
    args = parser.parse_args()
    
    # Safety check for macOS disk notation
    if "disk" in args.device and not args.device.startswith("/dev/"):
        print(f"Detected macOS disk notation. Use /dev/{args.device} instead of {args.device}")
        return 1
    
    try:
        write_raw_frames(args.device, args.frames_file, args.dry_run)
        return 0
    except Exception as e:
        print(f"ERROR: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 